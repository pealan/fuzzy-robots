# -*- coding: utf-8 -*-
"""trab.

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19nS8HsZeAp6Yr9GHGdRSsiZfvRMGIixM
"""

import sys,time
sys.path.insert(0, '../src')
from robot import Robot
import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
import matplotlib.pyplot as plt

braitenbergL=[-0.2,-0.4,-0.6,-0.8,-1.0,-1.2,-1.4,-1.6]
braitenbergR=[-1.6,-1.4,-1.2,-1.0,-0.8,-0.6,-0.4,-0.2]

detect = [0,0,0,0,0,0,0,0]
noDetectionDist = 1.0
maxDetectionDist = 0.2

def braitenberg(dist, vel):
    """
        Control the robot movement by the distances read with the ultrassonic sensors. More info: https://en.wikipedia.org/wiki/Braitenberg_vehicle
        Args:
            dist: Ultrassonic distances list
            vel:  Max wheel velocities
    """
    vLeft = vRight = vel
    for i in range(len(dist)):
        if(dist[i] < noDetectionDist):
            detect[i] = 1 - ((dist[i]-maxDetectionDist)/(noDetectionDist-maxDetectionDist))
        else:
            detect[i]=0
        for i in range(8):
            vLeft = vLeft + braitenbergL[i]*detect[i]
            vRight = vRight+ braitenbergR[i]*detect[i]

    return [vLeft, vRight]

def wall_follow(dist):
    distance_left = min(dist[:3])
    distance_right = min(dist[5:])
    distance_front = min(dist[3:5])
    walking.input['distance left'] = distance_left
    walking.input['distance right'] = distance_right
    walking.input['distance front'] = distance_front
    walking.compute()

    return [walking.output['velocity left'], walking.output['velocity right']]

distance_left = ctrl.Antecedent(np.arange(0.3, 5.01, 0.01), 'distance left')
distance_right = ctrl.Antecedent(np.arange(0.3, 5.01, 0.01), 'distance right')
distance_front = ctrl.Antecedent(np.arange(0.3, 5.01, 0.01), 'distance front')

velocity_left = ctrl.Consequent(np.arange(0.0,5.1,0.1), 'velocity left')
velocity_right = ctrl.Consequent(np.arange(0.0,5.1,0.1), 'velocity right')

distance_left['low'] = fuzz.trimf(distance_left.universe, [0.3, 0.3, 0.5])
distance_left['medium'] = fuzz.trimf(distance_left.universe, [0.4, 0.5, 1.0])
distance_left['high'] = fuzz.trapmf(distance_left.universe, [0.6, 1.0, 5.0, 5.0])

distance_right['low'] = fuzz.trimf(distance_right.universe, [0.3, 0.3, 0.5])
distance_right['medium'] = fuzz.trimf(distance_right.universe, [0.4, 0.5, 1.0])
distance_right['high'] = fuzz.trapmf(distance_right.universe, [0.6, 1.0, 5.0, 5.0])

distance_front['low'] = fuzz.trimf(distance_front.universe, [0.3, 0.3, 0.5])
distance_front['medium'] = fuzz.trimf(distance_front.universe, [0.4, 0.5, 1.0])
distance_front['high'] = fuzz.trapmf(distance_front.universe, [0.6, 1.0, 5.0, 5.0])

velocity_left['low'] = fuzz.trimf(velocity_left.universe, [0, 0, 2.5])
velocity_left['medium'] = fuzz.trimf(velocity_left.universe, [0, 2.5, 5.0])
velocity_left['high'] = fuzz.trimf(velocity_left.universe, [2.5, 5.0, 5.0])

velocity_right['low'] = fuzz.trimf(velocity_right.universe, [0, 0, 2.5])
velocity_right['medium'] = fuzz.trimf(velocity_right.universe, [0, 2.5, 5.0])
velocity_right['high'] = fuzz.trimf(velocity_right.universe, [2.5, 5.0, 5.0])

rule0 = ctrl.Rule(distance_left['high'] & distance_right['high'] & distance_front['high'], consequent = (velocity_left['high'],velocity_right['high']))
rule1 = ctrl.Rule((distance_left['low'] & (distance_right['medium'] | distance_right['high'])), consequent = (velocity_right['low'] , velocity_left['high']))
rule2 = ctrl.Rule((distance_right['low'] & (distance_left['medium'] | distance_left['high'])), consequent = (velocity_right['high'] , velocity_left['low']))
rule3 = ctrl.Rule((distance_front['medium']), consequent = (velocity_right['low'], velocity_left['medium']))
rule4 = ctrl.Rule(distance_front['low'], consequent = (velocity_right['low'], velocity_left['high']))
rule5 = ctrl.Rule((distance_left['medium'] & (distance_right['medium'] | distance_right['high'])), consequent = (velocity_right['medium'], velocity_left['low']))

velocity_control = ctrl.ControlSystem(rules=[rule0, rule1, rule2, rule3, rule4, rule5])

walking = ctrl.ControlSystemSimulation(velocity_control)

# walking.input['distance left'] = 0.38
# walking.input['distance right'] = 5.0
# walking.compute()
# print(walking.output['velocity left'],walking.output['velocity right'])
# velocity_left.view(sim = walking)
# plt.show()
# velocity_right.view(sim = walking)
# plt.show()

robot = Robot()
robot.set_left_velocity(3.0)
robot.set_right_velocity(3.0)
i = 0
while(robot.get_connection_status() != -1):
    us_distances = robot.read_ultrassonic_sensors()
    vel = wall_follow(us_distances[:8])
    robot.set_left_velocity(vel[0])
    robot.set_right_velocity(vel[1])
    if(i==1000):
        print(us_distances[:8])
        print("VELOCIDADE", vel)
        i=0
    i+=1
